import express from 'express';
import passport from 'passport';
import { v4 as uuidv4 } from 'uuid';
import axios from 'axios';
import sqlite3 from 'sqlite3';
import cors from 'cors';
import { randomBytes } from 'crypto';

const app = express();
app.use(cors());
app.use(express.json());

// Initialize a new database in memory
const db = new sqlite3.Database('./database.sqlite', (err) => {
  if (err) {
    console.error(err.message);
  }
  console.log('Connected to the SQLite database.');
});

// Create users table (if not exists)
db.run(`CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  name TEXT,
  email TEXT,
  profileUrl TEXT,
  workshopChoice TEXT
)`);

let stateStorage = {};

const router = express.Router();


//router.get(
  //"/linkedin",
  //passport.authenticate("linkedin", {
  // state: uuidv4(),
  // passReqToCallback: true,
  //}),
  //(req, res) => {}
 //);


// Endpoint to add a new user
router.post('/add-user', (req, res) => {
  const { name, email, profileUrl, workshopChoice } = req.body;

  // Assuming 'id' is generated by the database or is part of the request body
  const id = uuidv4(); // Generate a unique ID for the user

  db.run(`INSERT INTO users (id, name, email, profileUrl, workshopChoice) VALUES (?, ?, ?, ?, ?)`,
  [id, name, email, profileUrl, workshopChoice],
  (err) => {
    if (err) {
      console.error(err.message);
      res.status(500).json({ message: "Failed to add new user", error: err.message });
    } else {
      console.log(`New user added with id: ${id}`);
      res.status(201).json({ message: `New user added with id: ${id}` });
    }
  }
);
});



router.get('/auth/linkedin/callback', async (req, res, next) => {
  console.log('query', req.query)
  console.log('req.Body', req.body)
});

//Backup
router.get('/linkedin/callback', async (req, res, next) => {
  const { state, code } = req.query;
  console.log(`Received state on callback: ${state}, code: ${code}`); // Log the received state and code

  // Check if state exists in tempUserData and has not expired
  const tempData = tempUserData[state];
  if (!state || !tempData) {
    console.error('State is either missing or not found in tempUserData.');
    return res.status(401).send('State value is different or missing in tempUserData.');
  }

  if (tempData.expires < Date.now()) {
    console.error('State has expired.');
    return res.status(401).send('State has expired.');
  }

  console.log('State is valid, proceeding with authentication.');

  // Continue with the authentication logic
  try {
    const redirect_uri = process.env.CALLBACK_URL;
    const client_id = '77vbfdkm5xovst';
    const client_secret = 'gZzw0kQT4BVWUiW4';

    // Access token retrieval
    const access_token_url = `https://www.linkedin.com/oauth/v2/accessToken?grant_type=authorization_code&code=${code}&redirect_uri=${redirect_uri}&client_id=${client_id}&client_secret=${client_secret}`;
    let access_token;
    const res_token = await axios.post(access_token_url)
      .then((response) => {
        access_token = response.data.access_token;
        console.log('Access Token:', access_token);
      })
      .catch((err) => {
        console.error('Error retrieving access token:', err);
        throw err;
      });

    // Fetching user data
    if (access_token) {
      const user_info_url = 'https://api.linkedin.com/v2/userinfo';
      let userInfo = await axios.get(user_info_url, {
        headers: { Authorization: `Bearer ${access_token}` }
      }).then((response) => {
        return response.data;
      }).catch((err) => {
        console.error('Error fetching user info:', err);
        throw err;
      });

      if (userInfo) {
        console.log('User info:', userInfo);

        const { name, email, picture: profileUrl } = userInfo;
        const workshopChoice = tempData.workshopChoice;

        // Insert or update user data into SQLite database
        db.run(`INSERT INTO users (id, name, email, profileUrl, workshopChoice) VALUES (?, ?, ?, ?, ?)
          ON CONFLICT(id) DO UPDATE SET name = excluded.name, email = excluded.email, profileUrl = excluded.profileUrl, workshopChoice = excluded.workshopChoice`,
          [userInfo.sub, name, email, profileUrl, workshopChoice],
          function (err) {
            if (err) {
              console.error('Failed to save or update user data:', err.message);
              res.status(500).send("Failed to save or update user data");
            } else {
              console.log(`User added/updated with id: ${userInfo.sub}`);
              res.redirect('http://localhost:5173/workshops');
            }
          }
        );
      } else {
        console.error('User info not found.');
        res.status(500).send('User info not found.');
      }
    } else {
      console.error('Access token not found.');
      res.status(500).send('Access token not found.');
    }
  } catch (error) {
    console.error('Error during authentication:', error);
    res.status(500).json({
      message: "Internal Server Error",
      error
    });
  }
  
  // Clean up the temporary state data
  delete tempUserData[state];
});


// Rota para buscar os usuários
router.get('/users', (req, res) => {
  db.all("SELECT * FROM users", [], (err, rows) => {
    if (err) {
      res.status(500).send(err.message);
      return;
    }
    res.json(rows);
  });
});

// Rota para deletar um usuário
router.delete('/users/:id', (req, res) => {
  const id = req.params.id;
  db.run(`DELETE FROM users WHERE id = ?`, id, function(err) {
    if (err) {
      res.status(500).send("Error deleting the user");
    } else {
      res.send(`User with ID ${id} deleted`);
    }
  });
});

// Rota para deletar todos usuários
router.delete('/delete-all-users', (req, res) => {
  db.run("DELETE FROM users", [], (err) => {
    if (err) {
      res.status(500).send(err.message);
      return;
    }
    res.send("All users deleted successfully.");
  });
});

// Endpoint para atualizar a escolha do workshop de um usuário
router.post('/update-workshop', (req, res) => {
  const { userId, workshopChoice } = req.body;

  db.run(`UPDATE users SET workshopChoice = ? WHERE id = ?`, [workshopChoice, userId], (err) => {
    if (err) {
      res.status(500).send("Error updating workshop choice");
    } else {
      res.send(`Workshop choice updated for user ${userId}`);
    }
  });
});

let tempUserData = {};

router.post('/pre-login', (req, res) => {
  if (!req.body || !req.body.workshopChoice) {
    return res.status(400).send('workshopChoice is missing');
  }

  const { workshopChoice } = req.body;
  //const state = uuidv4(); // A variável 'state' é declarada aqui
  const state = randomBytes(16).toString('hex');


  // Log antes de salvar os dados
  console.log(`[Pre-login] Estado gerado: ${state} para a escolha de workshop: ${workshopChoice}`);

  // Salve a escolha do workshop e o estado em um objeto temporário
  tempUserData[state] = {
    workshopChoice: workshopChoice,
    expires: Date.now() + 300000 // 5 minutos
  };

  // Log para depuração
  console.log(`Pre-login initiated for workshop choice: ${workshopChoice} with state: ${state}`);

  // Responda com o estado que será usado para a autenticação posterior
  res.json({ state });
});


router.get('/linkedin', (req, res, next) => {
  // Se o parâmetro 'state' estiver presente na query, estamos na fase de callback
  const stateFromQuery = req.query.state;
  
  if (stateFromQuery) {
    // Lógica para lidar com o callback do LinkedIn
    console.log(`[LinkedIn Auth Callback] Estado recebido da query: ${stateFromQuery}`);
    if (!tempUserData[stateFromQuery]) {
      console.log('[LinkedIn Auth Callback] Estado inválido ou expirado.');
      return res.status(400).send('Invalid state parameter or state has expired');
    }
    console.log('[LinkedIn Auth Callback] Estado validado, prosseguindo com a autenticação.');


    // Prosseguir com a autenticação do LinkedIn
    passport.authenticate('linkedin', { state: stateFromQuery, passReqToCallback: true })(req, res, next);
  } else {
    // Não há estado na query, então estamos gerando um novo estado e iniciando o fluxo de login
    const newState = uuidv4();
    console.log(`Generated state: ${newState}`); // Log the generated state

    // Salve o estado gerado no objeto tempUserData com um tempo de expiração
    tempUserData[newState] = { expires: Date.now() + 300000 }; // 5 minutos para expirar

    // Iniciar autenticação com o LinkedIn, passando o estado recém-gerado
    passport.authenticate('linkedin', { state: newState, passReqToCallback: true })(req, res, next);
  }
});


export default router;
